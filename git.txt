hongyan0714@163.com
github: yhong061+0714
git clone https://github.com/yhong061/sample.git

git config --global user.email yhong@actions-semi.com
git config --global user.name yhong061

git add file
git commit -sm ""
git push origin master

git pull

===============================================================================
术语:

    工作区: learngit
    版本库: learngit/.git
    暂存区: learngit/.git/stage or learngit/.git/index

    第一个分支 : learngit/.git/refs/heads/master
    其他分支   : learngit/.git/refs/heads/test

    当前分支指针: learngit/.git/HEAD

    git add   : 将工作区的修改放到暂存区
    git commit: 将暂存区的修改放到当前分支, 暂存区清空
    git push  : 将分支上的修改提交到库中

===============================================================================
创建版本库
    //1. 创建一个空目录
    mkdir learngit

    //2. 这个目录变成Git可以管理的仓库
    cd learngit
    git init                               //空的仓库

    //3. 把文件添加到版本库
    git add readme.txt                     //把文件添加到仓库
    git commit -m "wrote a readme file"    //把文件提交到仓库

===============================================================================
仓库文件管理
    //1. 查看当前仓库的状态
    git status

    //2. 查看文件具体修改内容
    git diff readme.txt                    //查看工作区和暂存区的区别
    git diff HEAD -- readme.txt            //查看工作区和版本库的区别

    //3. 查看仓库提交记录
    git log                                //显示从最近到最远的提交日志
    git log --pretty=oneline               //显示从最近到最远的提交日志: 一行显示
    git log --graph --pretty=oneline --abbrev-commit
                                           //图形方式显示多分支的提交情况

    //4. 回退修改
    git reset HEAD file                    //把暂存区的修改撤销掉，重新放回工作区
    git checkout -- readme.txt             //放弃工作区的修改
       //git checkout readme.txt                //切换到另一个分支

    //5. 删除文件
    git rm test.txt                        //

===============================================================================
版本回退
    //   HEAD    ： 表示当前版本
    //   HEAD^   ： 表示上一个版本
    //   HEAD^^  ： 表示上上一个版本
    //   HEAD~100： 往上100个版本

    //1. 回退到上一个版本
    git reset --hard HEAD^

    //2. 跳到指定commit id的地方
    git reset --hard 3628164

    //3. 查找commit id
    git reflog                             //查看所有分支的所有操作记录
                                           //（包括commit,reset,已经被删除的commit记录)

===============================================================================
本地分支管理:
    //1. 创建dev分支，然后切换到dev分支
    git checkout -b dev

    //2. 查看分支，当前分支前面会标一个*号
    git branch

    //3. 把dev分支的工作成果合并到master分支上
    git checkout master
    git merge dev
    git merge --no-ff -m "merge with no-ff" dev 
                                           //--no-ff参数，表示禁用Fast forward
                                             //Fast forward模式下，删除分支后，会丢掉分支信息。
                                           //本次合并要创建一个新的commit，所以加上-m添加描述信息

    //4. 删除分支
    git branch -d dev

    //5. bug分支
    git stash                              //将dev分支上正在修改的代码储存起来
        git checkout master                //切到master分支
        git checkout -b issue-101          //基于master分支创建bug分支 
        git add readme.txt                 //修改bug
        git commit -m "fix bug 101"        //提交bug  
        git checkout master                //回到master分支
        git merge --no-ff -m "merged bug fix 101" issue-101
                                           //合并bug分支的提交到master分支上
        git branch -d issue-101            //删除bug分支
    git checkout dev                       //回到dev分支
    git stash list                         //查看储存区的状态
    git stash apply                        //恢复储存区
    git stash drop                         //删除储存区
    git stash pop                          //恢复并删除储存区
    git stash apply stash@{0}              //恢复指定储存区

===============================================================================
远程分支管理
    git remote                             //查看远程库的信息
    git remote -v                          //显示更详细的信息
    git push origin master                 //把该分支上的所有本地提交推送到远程库

===============================================================================
本地分支提交冲突

    //1. 创建新分支，修改文件，提交修改
    git checkout -b feature1               //创建新的feature1分支
    git add readme.txt 
    git commit -m "AND simple"

    //2. 切换到master分支，修改文件，提交修改 --> 文件冲突
    git checkout master
    git add readme.txt 
    git commit -m "& simple"

    //3. 合并分支，手动修改文件，提交修改
    //   Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改如下后保存
    git merge feature1
    git add readme.txt
    git commit -m "conflict fixed"

    //4. 删除分支
    git branch -d feature1


===============================================================================
远程分支提交冲突

    //1. 其他人修改远程dev分支
    git checkout -b dev origin/dev         //创建远程origin的dev分支到本地
    git add env                            //添加env文件
    git commit -m "add /usr/bin/env"       //提交到本地分支
    git push origin dev                    //提交到远程分支

    //2. 本人修改远程dev分支
    git add hello.py                       //添加hello.py文件
    git commit -m "add coding: utf-8"      //提交到本地分支
    git push origin dev                    //提交到远程分支  --> 冲突

    //3. 
    git branch --set-upstream dev origin/dev //建立本地分支与远程分支的连接
    git pull                               //取远程的新提交
    git commit -m "merge & fix hello.py"   //提交解决冲突后的修改
    git push origin dev                    //提交到远程分支

===============================================================================

git checkout master                    //切换到master分支
git tag v1.0                           //给master分支HEAD的地方打标签，名为v1.0
git tag                                //查看tag list
git tag v0.9 6224937                   //给commit id为6224937的提交打标签，名为v0.9
git show v0.9                          //查看v0.9标签处的详细信息
git tag -a v0.1 -m "version 0.1 released" 3628164
                                       //指定标签信息
git tag -d v0.1                        //删除
git push origin v1.0                   //推送某个标签到远程
git push origin --tags                 //送全部尚未推送到远程的本地标签

git tag -d v0.9                        //远程删除 : 先删除本地标签
git push origin :refs/tags/v0.9        //远程删除 ：删除远程标签


===============================================================================
生成SSH Key:
    //1. 创建SSH Key
    //   查看~/.ssh目录有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步
    //   id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。

    ssh-keygen -t rsa -C "youremail@example.com"     //然后一路回车，使用默认值即可

    //2. 登陆GitHub，打开“Account settings”，“SSH Keys”页面：
    //   点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容
    //   点“Add Key”，你就应该看到已经添加的Key：

    //   为什么GitHub需要SSH Key呢？
    //   因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协
    //   议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。
    //   当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里
    //   提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。

    //   最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。
    //   所以，不要把敏感信息放进去。

===============================================================================
将本地库克隆到远程库库:
    //1. 登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库

    //2. 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，
    //   就成功地创建了一个新的Git仓库

    //3. 关联本地仓库和github仓库: 
    //   本地的learngit仓库下运行fgit remote add命令
    //   origin为learngit在github仓库中的名字
    git remote add origin git@github.com:username/learngit.git

    //4. 把本地库的内容推送到远程
    //   由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的
    //   master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分
    //   支关联起来，在以后的推送或者拉取时就可以简化命令。
    git push -u origin master              //第一次推送
    git push origin master                 //非第一次推送:w

===============================================================================
将远程库克隆到本地库
    //1. 登陆GitHub，创建一个新的仓库，名字叫gitskills
    //   勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个
    //   README.md文件

    //2. 将远程库克隆到本地库
    //   GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git
    //   这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其
    //   他协议。
    //   使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只
    //   开放http端口的公司内部就无法使用ssh协议而只能用https。
    git clone git@github.com:username/gitskills.git

===============================================================================
搭建git服务器:
    //1. 安装git命令
    sudo apt-get install git

    //2. 创建git用户名
    sudo adduser git

    //3. 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入
    //   到/home/git/.ssh/authorized_keys文件里，一行一个。

    //4. 先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：
    sudo git init --bare sample.git

    //5. Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共
    //   享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以
    //   .git结尾。然后，把owner改为git：
    sudo chown -R git:git sample.git

    //6. 禁用shell登录：出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过
    //   编辑/etc/passwd文件完成
        git:x:1001:1001:,,,:/home/git:/bin/bash
    改为:
        git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell

    //7. 克隆远程仓库
     git clone git@server:/srv/sample.git

==============================
https:
echo "# self" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/yhong061/self.git
git push -u origin master

==============================
ssh:
echo "# self" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin git@github.com:yhong061/self.git
git push -u origin master

==============================
git remote add origin https://github.com/yhong061/self.git
git push -u origin master

==============================
git remote add origin git@github.com:yhong061/self.git
git push -u origin master

==============================
==============================
git clone https://github.com/yhong061/sample.git
cd sample
vim git.txt 
git add git.txt 
git commit -sm "add git.txt"
cat .git/config
git push origin  master 

==============================
git blame kernel/xc6130_reg/readme.txt  //list file's modify author per lines

==============================
git add -p readme.txt   //separate readme.txt's modification to serial parts
//s(separate) --> y(yes) --> n(no)

==============================
git rebase -i HEAD~2  //compress the last 2 commits to 1

==============================
git fsck --lost-found  //list the lost commit

==============================
//clone remote a branch not remote all branchs
git init
git remote add -t BRANCH_NAME_HERE -f origin REMOTE_REPO_URL_PATH_HERE
git checkout BRNACH_NAME_HERE

==============================
//save the changed filename to "update.zip" between serial commits
git archive -o ../updated.zip HEAD $(git diff --name-only HEAD^)  //save the changed filename between HEAD and HEAD^
git archive -o ../updated.zip NEW_COMMIT_ID $(git diff --name-only OLD_COMMIT_ID NEW_COMMIT_ID)  //save the changed file between NEW and OLD commit ID

==============================
==============================
==============================
