-------------------------------------------------------------------------------
malloc与calloc没有本质区别，malloc之后的未初始化内存可以使用memset进行初始化。

malloc与calloc分配的都是 连续空间
1. 主要的不同是malloc不初始化分配的内存，calloc初始化已分配的内存为0。
2. 次要的不同是calloc返回的是一个数组，而malloc返回的是一个对象。
3. calloc等于malloc后在memset很可能calloc内部就是一个malloc再来一个memset清0。
4. 所以malloc比calloc更高效。


-------------------------------------------------------------------------------
一. kmalloc():
用于申请较小的、连续的物理内存.
1. 以字节为单位进行分配，在<linux/slab.h>中
2. void *kmalloc(size_t size, int flags):分配的内存物理地址上连续，虚拟地址上自然连续
3. void kfree(const void *ptr):释放由kmalloc()分配出来的内存块

二.vmalloc():
用于申请较大的内存空间，虚拟内存是连续的
1. 以字节为单位进行分配，在<linux/vmalloc.h>中
2. void *vmalloc(unsigned long size) 分配的内存虚拟地址上连续，物理地址不连续
3. 一般情况下，只有硬件设备才需要物理地址连续的内存，因为硬件设备往往存在于MMU之外，根本不了解虚拟地址；但为了性能上的考虑，内核中一般使用 kmalloc()，而只有在需要获得大块内存时才使用vmalloc()，例如当模块被动态加载到内核当中时，就把模块装载到由vmalloc()分配 的内存上。
4.void vfree(void *addr)，这个函数可以睡眠，因此不能从中断上下文调用。


三.vmalloc()和kmalloc()区别
1.kmalloc保证分配的内存在物理上是连续的,那么它对应的虚拟内存肯定也是连续的,vmalloc保证的是在虚拟地址空间上的连续,但物理内存不一定连续.由于vmalloc()分配内存时,对应的物理内存是每个页框通过alloc_page()来分配.
2.kmalloc一般分配较小的内存,vmalloc分配较大的内存.
3.vmalloc比kmalloc要慢,且分配的虚拟地址空间位置不同.这两个函数所分配的内存虽然都处于内核空间(3GB～4GB),但对应的具体位置不同，kmalloc()分配的内存处于3GB～high_memory之间，而vmalloc()分配的内存在VMALLOC_START～VMALLOC_END之间，也就是非连续内存区。kmalloc分配的内存,它的物理地址与虚拟地址只有一个PAGE_OFFSET偏移，不需要为地址段修改页表,而vmalloc分配内存时需要修改主内核页表.

一般情况下在驱动程序中都是调用kmalloc()来给数据结构分配内存，而vmalloc()用在为活动的交换区分配数据结构，为某些I/O驱动程序分配缓冲区，或为模块分配空间，例如在include/asm-i386/module.h中定义了如下语句：

 #define module_map(x)           vmalloc(x)




-------------------------------------------------------------------------------
(1)C语言跟内存分配方式

<1>从静态存储区域分配.
    内存在 程序编译 的时候就已经分配好，这块内存在程序的整个运行期间都存在.
    例如全局变量、static变量.
<2>在栈上创建
    在 执行函数 时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放.
    栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限.

<3>从堆上分配，亦称动态内存分配.
    程序运行 的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存.


(2)C语言跟内存申请相关的函数主要有 alloca、calloc、malloc、free、realloc等.

<1>alloca是向 栈 申请内存,因此无需释放.
<2>malloc分配的内存是位于 堆 中的,并且没有初始化内存的内容,因此基本上malloc之后,调用函数memset来初始化这部分的内存空间.
<3>calloc则将初始化这部分的内存,设置为0.
<4>realloc则对malloc申请的内存进行大小的调整.
<5>申请的内存最终需要通过函数free来释放.

【attention】
三个函数的申明分别是:
void* malloc(unsigned size);
void* realloc(void* ptr, unsigned newsize);  
void* calloc(size_t numElements, size_t sizeOfElement); 
都在stdlib.h函数库内，它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL.

(1)函数malloc()
在内存的动态存储区中分配一块长度为size字节的 连续区域，参数size为需要内存空间的长度，返回该区域的首地址.

(2)函数calloc()
与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数，即在内存中申请numElements*sizeOfElement字节大小的连续地址空间.

(3)函数realloc()
给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度.

区别:
(1)函数malloc不能初始化所分配的内存空间,而函数calloc能.
(2)函数calloc() 会将所分配的内存空间中的每一位都初始化为零
(3)函数malloc向系统申请分配指定size个字节的内存空间.返回类型是 void*类型.void*表示未确定类型的指针.C,C++规定，void* 类型可以强制转换为任何其它类型的指针.
(4)realloc可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变.当然，对于缩小，则被缩小的那一部分的内容会丢失.realloc并不保证调整后的内存空间和原来的内存空间保持同一内存地址.相反，realloc返回的指针很可能指向一个新的地址.
(5)realloc是从堆上分配内存的.当扩大一块内存空间时，realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平；如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上.这句话传递的一个重要的信息就是数据可能被移动.





